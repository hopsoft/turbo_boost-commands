<%= cache session[:rpc_count].to_i do %>
  <div id="rpc">
    <%= render "stats/stats", id: "rpc-stats" do %>
      <%= render "stats/stat", label: "Counter", value: session[:rpc_count].to_i, class: "!bg-indigo-600 dark:!bg-indigo-900",
        value_class: ["!text-indigo-200 dark:!text-indigo-300"], label_class: ["!text-indigo-400 dark:!text-indigo-500"] %>
    <% end %>

    <p class="my-8 text-xl text-white">
      You can also use TurboReflex without explicitly defining Turbo Frames.
    </p>
    <p class="mt-4">
      This feature is known as <span class="text-blue-500">RPC over HTTP</span>.
      It eliminates the boilerplate and complexity imposed by Turbo Frames via a specialized frame dedicated to reflexes,
      allowing you to <span class="underline underline-offset-4">focus on business logic instead of frames</span>.
    </p>
    <p class="mt-4 mb-8">
    <em>And because it uses Turbo Frames under the hood, it guarantees robust and reliable reactivity over HTTP.</em>
    </p>

    <%= button_tag class: css("flowbite.button.cyan_to_blue", "block mb-8 ml-0 relative"),
      data: { turbo_reflex: "CounterRpcReflex#increment", turbo_frame: "turbo-reflex-frame" } do %>
      RPC over HTTP
      <%= render flowbite(:notification_badge), value: session[:rpc_count].to_i if session[:rpc_count].to_i > 0 %>
    <% end %>

    <%= render component(:code), language: :ruby, class: "text-sm",
      path: "app/reflexes/counter_reflex.rb", source_path: "app/views/codes/increment/rpc_over_http/reflex.rb" %>

    <div class="my-8"></div>

    <%= render component(:code), language: :erb, class: "text-sm",
      path: "app/views/demos/_counter.html.erb", source_path: "app/views/codes/increment/rpc_over_http/partial.erb" %>

    <div class="my-8"></div>

    <%= render component(:code), language: :erb, class: "text-sm",
      path: "Rendered HTML for: app/views/demos/_counter.html.erb", source_path: "app/views/codes/increment/rpc_over_http/partial.html", erb: true %>
  </div>
<% end %>
